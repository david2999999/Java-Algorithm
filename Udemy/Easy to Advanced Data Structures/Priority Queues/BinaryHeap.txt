Ways of Implementing a Priority Queue
    - Priority Queues are usually implemented with heap since this gives them the best possible
      time complexity
    - PQ is an abstract data type, hence heap are not the only way to implement PQ
        - We can use an unsorted list to implement a PQ, but it will not give us the best time complexity
    - There are many types of heaps we could use to implement a PQ
        - Binary Heap
        - Fibonacci Heap
        - Binomial Heap
        - Pairing Heap

Binary Heap
    - A binary tree that supports the heap invariant.
        - In a binary tree every node has exactly two children
    - A complete binary tree is a tree in which at every level, except possibly the last is completely filled
      and all the nodes are as far left as possible
        - This will be helpful later when we are inserting element into the heap

Binary Heap Representation with array
    - Let i be the parent node index (zero based)
        - Left child index: 2i + 1
        - Right child index: 2i + 2

Adding Elements to Binary Heap
    - We insert the element at our bottom left of our tree
    - Then we use 'bubbling up' to move it to the right position
        - This bubbling procedure compares our new element with its parent element
        - If the order violates the heap invariant, we will swap the two elements

Removing Elements from a Binary Heap
    - How do we perform a polling operation in our binary heap?
        - We swap the root of our tree with our rightmost element
            - Our swap may violate the heap invariant
            - So we have to perform 'bubbling down' on our root node
    - How do we perform a removal of a node from our heap?
        - We have to find the node
        - Then we will swap the node with the rightmost element of our tree
        - Remove the node that we are trying to delete
        - If we violate the heap invariant, we have to bubble up/down to satisfy heap invariant
    - What is the time complexity of polling/removal?
        - Polling - O(logn)
        - Removing - O(n) - We may need to search the entire tree for the node.

Removing Elements from Binary Heap in O(logn)
    - The inefficient of the removal algorithm comes from the search for the element.
        - We can use a HashTable to find our where a node is index at
    - A hashtable provides a constant time lookup and update for a mapping from a key to a value
    - How do we deal with multiple values?
        - Instead of mapping one value to one position, we will map one value to multiple positions
            - We can maintain a Set or Tree set of indexes for which a particular node value maps to
        - Does it matter which position we remove the values from?
            - No, as long as we fulfill the heap invariant, we are fine





