Question
    Given information about active users on the network, find the shortest route for a message from one user (the sender) to another (the recipient).
    Return an array of users that make up this route.

Thoughts before Coding
    - What data structure can be used to represent a network of users?
        - Graph!
    - Now, we need to find shortest path between two nodes
        - How do we know if there is even a path between 2 nodes?
            - What traversal can we use?
                - Breath first search
                - Depth first search
        - We should use Breath first search to find the shortest path, because it searches for nodes that are neighbors
          to our current node first.
        - If we use a depth first search, we may miss a node by one degree and we will end up searching many other users.
    - After we know there is a path between 2 nodes
        - How will we reconstruct our path?
        - For each of the nodes, we need to know the previous node in order to backtrack our path

Answer
    - We will perform a breath first search from our starting node to search for our ending node
        - What is needed for breath first search?
            - We need a queue of nodes, so we can process the neighbors of our current node first
            - To prevent cycles, we will also have a HashSet to hold nodes that we have already traversed
            - What happens when we find our end node?
                - How do we backtrack and construct a path?
        - We can keep track of our current value and previous value with a HashMap
            - Key = current value
            - Value = previous value
            - Our starting node will have a previous value of null, because it is the front of the path
        - After we have found our ending node
            - We will use the HashMap to check for the previous value
            - We will add the values into a list to construct a path
        - After constructing the path, we will need to reverse it.
            - Because we constructed the path from the end node. So the list is reversed
            - This can be prevented by using a LinkedList and using the addFirst method instead
            - In the current example, we used an ArrayList and all elements are added to the end of the list

Gotcha
    - Queue interface inherits isEmpty method from its super interface.
    - Converting a list to array with the built in method
        - list.toArray(new type[list.size()])
    - Use a HashMap when trying to construct a path
        - Key - Current Node
        - Value - Previous Node