Question
    Given information about active users on the network, find the shortest route for a message from one user (the sender) to another (the recipient).
    Return an array of users that make up this route.

Thoughts before Coding
    - What data structure can be used to represent a network of users?
        - Graph!
    - Now, we need to find shortest path between two nodes
        - How do we know if there is even a path between 2 nodes?
            - What traversal can we use?
                - Breath first search
                - Depth first search
        - We should use Breath first search to find the shortest path, because it searches for nodes that are neighbors
          to our current node first.
        - If we use a depth first search, we may miss a node by one degree and we will end up searching many other users.
    - After we know there is a path between 2 nodes
        - How will we reconstruct our path?
        - For each of the nodes, we need to know the previous node in order to backtrack our path

Answer
    - We will perform a breath first search from our starting node to search for our ending node
        - What is needed for breath first search?
            - We need a queue of nodes, so we can process the neighbors of our current node first
            - To prevent cycles, we will also have a HashSet to hold nodes that we have already traversed
            - What happens when we find our end node?
                - How do we backtrack and construct a path?
        - We can keep track of our current value and previous value with a HashMap
            - Key = current value
            - Value = previous value
            - Our starting node will have a previous value of null, because it is the front of the path
        - After we have found our ending node
            - We will use the HashMap to check for the previous value
            - We will add the values into a list to construct a path
        - After constructing the path, we will need to reverse it.
            - Because we constructed the path from the end node. So the list is reversed
            - This can be prevented by using a LinkedList and using the addFirst method instead
            - In the current example, we used an ArrayList and all elements are added to the end of the list
    - Optimizations we can make,
        - We are currently using 3 data structure in our breath first search
            - Queue, HashMap, HashSet
        - When we add values to our HashSet, we are also adding it into our HashMap
        - We can remove our HashSet and just use HashMap to indicate if a value has already been visited
    - What is the time and space complexity?
        - Time complexity = O(n) + O(n) = O(n)
            - O(n) - for our breath first search
            - O(n) - backtrack and reconstruct our path via HashMap
        - Space complexity = O(n) + O(n) + O(n) = O(n)
            - O(n) - HashMap
            - O(n) - Queue
            - O(n) - The list for our path from start to end

Side cases to Consider?
    - We need to make sure both our starting and ending node is inside our graph.

Gotcha
    - Queue interface inherits isEmpty method from its super interface.
    - Converting a list to array with the built in method
        - list.toArray(new type[list.size()])
    - Use a HashMap when trying to construct a path
        - Key - Current Node
        - Value - Previous Node