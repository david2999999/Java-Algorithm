Question
    Write a method to check that a binary tree is a valid binary search tree

Thoughts before Coding
    - What does it mean to be a valid binary search tree?
        - If a node is on the ancestor's left subtree, it must be less than the ancestor
        - If a node is on the ancestor's right subtree, it must be larger than the ancestor
    - So, we need to keep track of the ancestor and make sure the left/right subtrees follow this rule
    - What are the different ways we can approach this problem? What traversals can be choose?
        - What is the difference between choosing breath first search and depth first search?
            - Both of them uses O(n) memory in the worst case
            - Depth first search is likely to be more space efficient than breath first traversal, if the tree is balanced
              then the space will be O(lgn), but if it is unbalanced it'll be O(n)
            - The memory required for breath first search is the breath of the tree, which doubles in size as we traverse deeper into the tree.
        - But, we also need to keep track of the parent nodes other than the nodes themselves.
            - How many parent nodes are there for a single node?
                - For a balanced tree, there are logn parents
                - For an unbalanced tree, there are n parents
            - So this may result in O(nlogn) or O(n^2) memory, can we do better?
        - When we looking at the binary tree, we do not need to keep track of all the parent nodes. We just need to know the lower/upper bound values
          for each of the nodes based on its parent.

Answer
    - We can create a new class to hold our current node, upperbound and lowerbound values.
        - This new class will be used as we push nodes into the stack for the depth first search
    - But, before we start the depth first search, we need to push our root node into the stack. What should the lower/upper bound be our root node be?
        - Since, we are allowing any value for our root node. The lower bound can be Integer.MIN_VALUE and upper bound can be Integer.MAX_VALUE.
    - Then for each depth first search iteration we can compare the value of our current node with the upper/lower bound values.
        - If the value is less than or equal to the lower bound, return false
        - If the value is greater than or equal to the upper bound, return false
    - How do we add new child nodes into our stack?
        - When adding our left node, we first need to check if it is null or not.
            - If it is not null, we can add it into our stack, but what is the new lower/upper bound for this left child?
            - Since, we are traversing to the left, we have to update our upper bound to the value of our parent node.
            - The lower bound can stay the same, because we only want to make sure our left child does not have a greater value than our parent node.
        - When adding our right node, we first need to check if it is null or not.
            - If it is not null, we can add it into our stack, but what is the new lower/upper bound for this right child?
            - Since, we are traversing to the right, we have to update our lower bound to the value of our parent node.
            - The upper bound can stay the same, because we only want to make sure our right child has a greater value than our parent node.
    - What is the time and space complexity of this solution?
        - Time complexity - O(n) - where n is the number of nodes in the tree.
        - Space complexity
            - O(logn) - balanced tree
            - O(n) - unbalanced tree

    - We can actually use a recursive solution, then we do not need our new class from our previous example
        - For each of the recursive call, we will provide our lower/upper bound in the parameters of our recursive function
        - We can start with our root node again
            - Our initial lower bound for root node will be the same Integer.MIN_VALUE
            - Our initial upper bound for root node will be the same Integer.MAX_VALUE
        - What is our base case for our recursive call?
            - If we have hit the null nodes, we can return true
            - That means we have checked all the nodes above it
        - For each recursive call
            - we will check if our current node is greater than our lower bound
            - we will check if our current node is smaller than our upper bound
            - Then we will make a recursive call to our left node and update the upper bound to the value of our current node
            - Then we will make a recursive call to our right node and update the lower bound to the value of our current node

