Question
    Write a method to see if a binary tree is "superbalanced" (a new tree property we just made up).
    A tree is "superbalanced" if the difference between the depths of any two leaf nodes is no greater than one.

Thoughts before Coding
    - Can we just compare each leaf node with just its sibling?
        - No, we need to consider all of the other leaf nodes too
    - Can we just compare the depth of a treeNode with the depth of all the other leaf nodes?
        - If there are n leafs, there will be n^2 leaf pairs,
            - Our time complexity will become O(n^2), can we do better?
    - If the difference between the depths of any two leaf nodes is not greater than 1, that means
      there are only at most 2 depths, if we found more than two different depths, that means the tree is
      not superbalanced.
    - What if we have two different depths? We will need to check if the two depths have a difference of 1
    - How do we know if a tree is a leaf?
        - Left and right children are null

Answer
    - Since, most of our concerns are with the leaf nodes in the binary tree, we need a quick way to get to the leafs
        - We will use depth first search instead of breath first search
    - Since, we are concerned with the number of depths in our tree, we will create an ArrayList to store our depths
        - If we store 3 different type of depths, we will know that the tree is not superbalance
        - If we have 2 different type of depths, we need to make sure the difference between them is at most 1
    - As we traverse the binary tree, we also need to find a way to keep track of the depth of each node
        - We will create a class to hold both the node and the depth
    - Depth first traversal implementation
        - Initialize a stack, this will be used for our depth first traversal instead of recursion
        - Add our root node with a depth of 0 into our stack
        - While our stack is not empty
            - pop the top element from our stack
            - Check if the top element is a leaf
                - if the element is a leaf
                    - check if our list contains the depth of this leaf
                        - if this depth is not in our depth list
                            - Add the depth into our list
                            - 1) Check if our depth list does not have more than 2 elements
                            - 2) Check if our depth list has 2 elements and the difference is not greater than 1
                            - If any of these 2 conditions fail, return false
            - Add the left node if not null
            - Add the right node if not null
    - return true











