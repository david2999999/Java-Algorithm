Question
    Write a method to see if a binary tree is "superbalanced" (a new tree property we just made up).
    A tree is "superbalanced" if the difference between the depths of any two leaf nodes is no greater than one.

Thoughts before Coding
    - Can we just compare each leaf node with just its sibling?
        - No, we need to consider all of the other leaf nodes too
    - Can we just compare the depth of a treeNode with the depth of all the other leaf nodes?
        - If there are n leafs, there will be n^2 leaf pairs,
            - Our time complexity will become O(n^2), can we do better?
    - If the difference between the depths of any two leaf nodes is not greater than 1, that means
      there are only at most 2 depths, if we found more than two different depths, that means the tree is
      not superbalanced.
    - What if we have two different depths? We will need to check if the two depths have a difference of 1
    - How do we know if a tree is a leaf?
        - Left and right children are null

Answer
    - Since, most of our concerns are with the leaf nodes in the binary tree, we need a quick way to get to the leafs
        - We will use depth first search instead of breath first search
    - Since, we are concerned with the number of depths in our tree, we will create an ArrayList to store our depths
        - If we store 3 different type of depths, we will know that the tree is not superbalance
        - If we have 2 different type of depths, we need to make sure the difference between them is at most 1
    - As we traverse the binary tree, we also need to find a way to keep track of the depth of each node
        - We will create a class to hold both the node and the depth
    - Depth first traversal implementation
        - Initialize a stack, this will be used for our depth first traversal instead of recursion
        - Add our root node with a depth of 0 into our stack
        - While our stack is not empty
            - pop the top element from our stack
            - Check if the top element is a leaf
                - if the element is a leaf
                    - check if our list contains the depth of this leaf
                        - if this depth is not in our depth list
                            - Add the depth into our list
                            - 1) Check if our depth list does not have more than 2 elements
                            - 2) Check if our depth list has 2 elements and the difference is not greater than 1
                            - If any of these 2 conditions fail, return false
            - Add the left node if not null
            - Add the right node if not null
    - return true

    - What is the time and space complexity of this solution?
        - The space complexity is O(3) + O(n) = O(n)
            - We have 2 data structures
                - one list to keep track of the depths, which will store at most 3 elements - O(3)
                - one stack to keep track of the nodes, the stack will hold at most d nodes where d is the
                  depth of the tree, so we can say that our cost is O(d)
                    - In a balance binary tree we can say O(d) = O(logn)
                    - In an unbalanced binary tree, O(d) = O(n)
                        - In the worst case, the tree is a straight line of right children from the root where every
                          node in that line also has a left child. The traversal will walk down the line of right children,
                          adding a new left child to nodes at each step. When the traversal hits the rightmost node,
                          nodes will hold half of the n total nodes. Half n is O(n), so the worst case is O(n)
        - The time complexity is O(n)
            - The worst case is when the tree is balanced and we need to traverse every single node.










