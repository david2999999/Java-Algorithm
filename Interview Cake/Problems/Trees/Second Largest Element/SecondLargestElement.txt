Question
    Write a method to find the 2nd largest element in a binary search tree

Thoughts before coding
    - Before we find the 2nd largest element, we should find the largest element first and try to go from there
        - How do we find the largest element in a binary tree?
            - The largest element is the rightmost node of our tree
    - After finding the largest element, where is our 2nd largest element?
        - Our 2nd largest element is the parent of our largest element!
        - But, what if our largest node has a left subtree? Does this rule still hold?
            - No, if our largest node has left subtree, that means the 2nd largest element is in this left subtree
            - Where do we find the largest element in the left subtree? It is still the rightmost node
            - So, we have to find the rightmost node in our left subtree if it is present

Answer
    - For the first solution, we will use a recursive approach
        - There are 2 base cases we need to look out for
            - we need to make sure there is at least 2 nodes inside the binary tree, because we are looking for the 2nd highest
                - The root node must not be null
                - At least one of the left/right child must not be node
        - When recursing through the binary search tree, for every node
            - check if we only have a left subtree and our right children is null
                - that means we have reached the largest element, and our 2nd largest element is inside the rightmost node in our left subtree
                - traverse the left subtree to find our 2nd largest value
            - check if our right child is not null and if the right child does not have any children
                - this means our right child is the largest node
                - our current node is the 2nd largest node, because the largest node does not have a left subtree
                - return our current node
        - recurse to the right of our tree (since the largest elements are all on the right side)
    - What is the time and space complexity for this recursive solution?
        - Time complexity = O(h), where h is the height of the tree,
            - The height of the tree is O(logn) for a balance tree
            - And O(n) for an unbalanced tree
        - Space complexity = O(h), this is our recursive call stack. We can avoid this call stack by using iterative approach (2nd solution)

    - For our second solution, we will use the iterative approach
        - We will validate our input first, the same way as our first solution
            - we need to make sure there is at least 2 nodes inside the binary tree, because we are looking for the 2nd highest
                - The root node must not be null
                - At least one of the left/right child must not be node
        - We will use a while loop instead of recursion, this while loop will continue to iterate until we find our 2nd largest element
            - We first start with our root node
                - check if we only have a left subtree and our right children is null
                    - that means we have reached the largest element, and our 2nd largest element is inside the rightmost node in our left subtree
                    - traverse the left subtree to find our 2nd largest value
                - check if our right child is not null and if the right child does not have any children
                    - this means our right child is the largest node
                    - our current node is the 2nd largest node, because the largest node does not have a left subtree
                    - return our current node
            - In order to traverse to the right subtree, we can do (node = node.right)
        - What is the time complexity for this iterative solution?
            - Time complexity = O(h), where h is the height of the tree,
                - The height of the tree is O(logn) for a balance tree
                - And O(n) for an unbalanced tree
            - Space complexity = O(1) - we are not using any data structure or recursive stack