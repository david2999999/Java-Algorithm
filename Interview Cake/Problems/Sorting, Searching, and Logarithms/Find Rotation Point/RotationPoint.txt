Question
    I opened up a dictionary to a page in the middle and started flipping through, looking for words I didn't know. I put each word I didn't know at increasing indices
    in a huge array I created in memory. When I reached the end of the dictionary, I started from the beginning and did the same thing until I reached the page I started at.

    Now I have an array of words that are mostly alphabetical, except they start somewhere in the middle of the alphabet, reach the end,
    and then start from the beginning of the alphabet. In other words, this is an alphabetically ordered array that has been "rotated."

    Write a method for finding the index of the "rotation point," which is where I started working from the beginning of the dictionary.
    This array is huge (there are lots of words I don't know) so we want to be efficient here.

Thoughts before Coding
    - So the array is partially sorted, and we need to find a value inside this array
        - This seems like we can use binary search
        - But, binary search works on a fully sorted array
        - Is there a way to do a modified binary search?
    - Lets first write our an example
        [q, w, e, r, a, b, c, d, e]
    - We can see that the elements after the rotation point (r) are all lower alphabetical order than the front of the front of the array
    - if the value at our current index is lower than the value at the front of the array
        - We have to search our rotation point at the left side
            [q, w, e, r, a, b, c, d, e]
        - In this example, the value of (a) is less than the value of (q), so our rotation point must be on the left
    - if the value at our current index is greater than or equal to the value at the front of the array
        - We have to search to the right
        - in this example, the value of (t) is greater than (q), so our rotation point must be on the right
            [q, w, e, r, t, b, c, d, e]
        - in this example, the value of (q) is equal to (q), so our rotation point must be on the right
            [q, q, q, q, q, b, c, d, e]

Gotchas
    - When search to the left/right, we need to make sure it is inclusive of our current middle index
