Question
    I opened up a dictionary to a page in the middle and started flipping through, looking for words I didn't know. I put each word I didn't know at increasing indices
    in a huge array I created in memory. When I reached the end of the dictionary, I started from the beginning and did the same thing until I reached the page I started at.

    Now I have an array of words that are mostly alphabetical, except they start somewhere in the middle of the alphabet, reach the end,
    and then start from the beginning of the alphabet. In other words, this is an alphabetically ordered array that has been "rotated."

    Write a method for finding the index of the "rotation point," which is where I started working from the beginning of the dictionary.
    This array is huge (there are lots of words I don't know) so we want to be efficient here.

Thoughts before Coding
    - So the array is partially sorted, and we need to find a value inside this array
        - This seems like we can use binary search
        - But, binary search works on a fully sorted array
        - Is there a way to do a modified binary search?
    - Lets first write our an example
        [q, w, e, r, a, b, c, d, e]
    - We can see that the elements after the rotation point (r) are all lower alphabetical order than the front of the front of the array
    - if the value at our current index is lower than the value at the front of the array
        - We have to search our rotation point at the left side
            [q, w, e, r, a, b, c, d, e]
        - In this example, the value of (a) is less than the value of (q), so our rotation point must be on the left
    - if the value at our current index is greater than or equal to the value at the front of the array
        - We have to search to the right
        - in this example, the value of (t) is greater than (q), so our rotation point must be on the right
            [q, w, e, r, t, b, c, d, e]
        - in this example, the value of (q) is equal to (q), so our rotation point must be on the right
            [q, q, q, q, q, b, c, d, e]

Answer
    - We should validate if our array has at least 2 elements
        - if not throw an exception
    - We will first declare a variable to keep track of the first element inside our array
    - Then we will have a floor/ceiling index to keep track of the range we are currently searching through
        - floor is initially 0
        - ceiling is initially array.length - 1
    - How do we know if we found our rotation point?
        - When our floor and ceiling index are adjacent to each other
        - That means floor is the largest value before we start over
        - And ceiling will be our first smallest element (aka our rotation point)
    - Our search will involve a 'while' loop with the conditional (floor < ceiling)
        - We will get our middle element
            - We can compare this middle element with the value at the front of the array
        - if our middle element is greater than or equal to our value at the front
            - We have to search the right side (middle index -> ceiling) inclusive
        - if our middle element is less than our value at the front
            - We have to search the left side (floor -> middle index) inclusive
        - When our floor and ceiling are adjacent indices
            - We can break out of our 'while' loop
    - return ceiling

    - What is the time/space complexity?
        - Time complexity = O(k * logn)
            - O(k) - k is the length of the string, since we are comparing strings
            - O(logn) - We are factoring out half of the elements at a time
        - Space complexity = O(1)

Gotchas
    - When search to the left/right, we need to make sure it is inclusive of our current middle index
