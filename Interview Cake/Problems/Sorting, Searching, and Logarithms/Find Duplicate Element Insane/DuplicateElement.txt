Question
    In Find a duplicate, Space Editionâ„¢, we were given an array of integers where:
        the integers are in the range 1..n
        the array has a length of n + 1

    These properties mean the array must have at least 1 duplicate. Our challenge was to find a duplicate number,
    while optimizing for space. We used a divide and conquer approach, iteratively cutting the array in half to find a duplicate integer in O(nlgn) time and O(1) space (sort of a modified binary search).
    But we can actually do better. We can find a duplicate integer in O(n) time while keeping our space cost at O(1).

Answer
    - The elements inside our array can be treated as a list of nodes and can be created into a linkedlist
        - The values inside each of the indexes can be treated as a next pointer to a position.
        - Positional index starts with 1 instead of 0. (I think this is because we have unique numbers from 1 - n), We want each value to have its own position.
        - For example if the value at A[5] = 4, this means our next value is at position 4.
        - But, how do we know where is the head of the linkedlist?
    - We found out that for the duplicate element, there will always be 2 pointers pointing into the node. This is because there are 2 values inside the array that are the same.
      As a result, both values points to the same positional index.
    - The question is how to know which node has 2 pointers?
        - First, we found out that the last element inside the array does not have a pointer coming into the node, this is because of the positional index. Inside our array, there are only
          n unique values from (1 - n) and the positional index at the last element is n + 1. So, we can actually treat this index as the head of our linkedlist.
        - Second, we found out that every node has a value of 1 - n, so every node points to another node or itself. This results in a loop inside our linkedlist
        - Third, only the starting point of the loop has two pointers pointing into the node
        - Our answer will be this starting point of the loop, but how exactly do we find it?
            - In order to find the starting point of the loop, we need to use the 2 pointer approach
                - The faster pointer has to start from the head of the linkedlist and move forward the same number of steps as the length of the loop
                - Then both the slow and fast pointer have to move at the same pace until they equal each other. The position, where they meet, will be our starting point of the loop
                    - But how do we find the length of the loop?
                        - We need to get inside the loop, save that position, and count number of steps to come back to the position again
                        - So, how do we get inside the loop?
                            - We have our head node of the list. If we move n (number of elements in the array) steps from the head of list, we will definitely get into the loop. This is because
                              the worst case scenario we have a loop at all the way at the end of our linkedlist.
                            - After, getting into the loop, count the number of steps to get back to the position again
                    - After, finding the length of loop. Create two pointers, slow/fast
                        - Move fast D number of steps, where D is the length of the loop
                        - Then move both slow and fast until they equal
                        - return either slow/fast pointer, since they are equal and also at the start of the loop.

Gotchas
    - When moving elements of the linkedlist, the value inside array index is the next pointer
        - This helps us save space by not creating a separate linkedlist
    - The last element always do not have an incoming pointer because the positional index is too large for the other elements
    - Since, each node always have a pointer to another node or itself, there will be a loop
    - To find the starting point of the loop,
        - Move the fast pointer D steps (length of loop) first
        - Then move both slow and fast pointer until they touch

