Question
    Hooray! It's opposite day. Linked lists go the opposite way today.
    Write a method for reversing a linked list. Do it in place.
    Your method will have one input: the head of the list.
    Your method should return the new head of the list.

Thoughts Before Coding
    - Lets first find a way of not doing it in place and get back to it later
    - Since, to reverse a linked list, we can push a copy of the node into a stack
        - Then when we pop all of the elements out, our linked list will be reversed
    - What is the time and space complexity?
        - Time complexity = O(n) + O(n)
            - O(n) - Push our elements into the stack
            - O(n) - Pop our elements our of the stack to generate a reversed linked list
        - Space complexity = O(n)

Solution
    - Can we reverse the linked list in place?
    - In order to do so, we must modify our next pointer of each node to point to the previous value
        - How do we handle the case of our first node?
            - When reversed, its next node value is NULL
            - We can first declare a NULL node to handle this case
                - Our first node's next pointer can point to this NULL node
        - All of the other nodes can point to its previous node
    - How will be traverse the linked list?
        - Before pointing our current node to its previous node
        - We have to make sure to save our next node.
            - If we do not save our next node, it will be lost when we try to construct our reverse list!
            - And if we lost our next node, we will not be able to finish traversing the list
    - Our terminating condition will be when we reached the end of our linked list
        - and our reverse linked list will be constructed

    - What is the time and space complexity?
        - Time complexity = O(n)
            - We will only be iterating our list one time to create our reverse list
        - Space complexity = O(1)
            - We have reversed our linked list using the original inputs