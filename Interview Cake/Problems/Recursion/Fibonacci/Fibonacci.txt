Question
    Write a method fib() that takes an integer nn and returns the nth Fibonacci number.
    Let's say our Fibonacci series is 0-indexed and starts with 0. So:

Thoughts before Coding?
    - How do we find a fibonacci number?
        - Every fibonacci number is the sum of its previous 2 fibonacci numbers, with the exception of 0 and 1
            - fib(0) -> 0
            - fib(1) -> 1
        - If we are doing recursive way, there 2 can be our base case.

Answer
    - Recursive solution
        - Our base case is when our current fibonacci index is either 0 or 1
            - fib(0) -> 0
            - fib(1) -> 1
        - The fibonacci of the current index n, is the sum of fib(n - 1) and fib(n - 2)
        - What is our runtime and space complexity for this solution?
            - Our space complexity will be the memory usage of our recursive stack, which if we draw it out into a binary tree. We can see the height of the binary tree is our stack memory usage, O(n).
            - Our time complexity will be the number of nodes or recursive calls from calculating each fibonacci index. There are 2^n nodes inside our binary tree, thus our runtime is O(n^2)
        - We need to reduce our time complexity cause there are so many overlapping calculations. This can be done with memoization.

    - Memoization solution
        - When making recursive calls, sometimes there are overlapping recursive calls (the calls that runs on the same input multiple times)
        - In order to not make overlapping calls, we create a cache or memo to hold previously calculated results.
            - The cache is mostly a hashtable, where the input of the recursive function is the key and the result of the recursive call is the value.
            - So, during every recursive call, we can check the memo to check if we already calculated the result for this input value
                - If there is a value in the memo, return the value
                - Else, calculate the result
                    - add the input and result into the memo
        - So, for this solution, in each of the recursive calls
            - We will first check for the base case (0 or 1)
            - Then we will check if we have already calculated this index before from our memo
                - return the cached solution if present
            - If we have not calculated this index yet
                - Calculate the fibonacci number for this index
                - Add the result to our hashtable. (key -> index, value -> result)
            - return the result
        - What is our runtime and space complexity for this solution?
            - Our space complexity will be the memory usage of our recursive call stack, if we draw out the tree again. The height of the tree is n, which is the size of our call stack O(n).
            - Our time complexity is much better this time, because we are not making overlapping recursive calls. So the binary tree looks just like an unbalance tree. Since, we are only
              making the necessary recursive calls for each index, our runtime is now O(n)

    - Bottom-up Solution
        - When using the memoization solution, we found out that we are using O(n) space because of our recursive stack.
        - We can get to O(1) space complexity if we do not use recursion, thus we will use an iterative approach with the bottom-up solution
        - The bottom-up approach requires us to start from the beginning and get to the result (which is the result at the specific index that we want)
            - The beginning of the fibonacci number starts with index 0 or 1
            - We can start to build the next values from these 2 base cases
        - We can iterate to that specific index using a 'for' loop, and keeping track of 3 variables
            - previous previous (initially 0, because fib(0) = 0)
            - previous (initially 1, because fib(1) = 1)
            - current (can be initialized to 0)
        - Don't forget to update the following variables after each iteration
            - (current) = (previous previous) + (previous)
            - (previous previous) to (previous)
            - (previous) to (current)
        - return our current variable

Gotchas
    - It will be easy to spot overlapping calls by drawing out a tree
    - It will be easier to spot the runtime of recursion by drawing it out into a tree
    - Do not forget about the memory usage that we use by doing recursive calls
    - We can prevent overlapping recursive calls with memoization
    - We can save memory usage from the recursive call stack by using a bottom up approach
