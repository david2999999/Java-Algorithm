Question
    They found out you're a programmer and asked you to solve something they've been wondering for a long time.

    Write a method that, given:
        1) an amount of money
        2) an array of coin denominations

    computes the number of ways to make the amount of money with coins of the available denominations.

Different Approaches to the Problem
    1) Top down approach, recursive method
        - For each of the denominators, we will check how many ways we are able to use this denominator once, twice or
          as many times as it takes before it overshoot the amount with coins of that denominator alone.
            - For example, if we have denominators [1, 3, 5] to make 5 (our amount)
                - We will first start with zero (1 coin) and check how many ways to make remaining amount (amount - 0) with (3, 5)
                - Then we will use one (1 coin) and check how many ways to make remaining amount (amount - 1) with (3, 5)
                - Then we will use two (1 coin) and check how many ways to make remaining amount (amount - (1 * 2)) with (3, 5)
                    - This will continue on until, how many ways to make remaining amount (amount - (1 * 5)) with (3, 5)
                    - Since, our amount is 5, the maximum number of (1 coin) that we can use is 5.
        - For each of denominator choices, we are left with the subproblem of seeing how many ways we can get the
          remaining amount from the remaining denominators
            - For example, from the previous example
                - We have to check how many ways to find the remaining amount (5) with (3, 5)
                    - We will first start with zero (3 coin) and check how many ways to make amount (5) with (5)
                    - Then we will use one (3 coin) and check how many ways to make (amount - 3 = 2) with (5)
                    - we can not use 2 * (3 coin) because it will overshoot our amount
        - Base cases we have to consider
            - If the amount left after each recursive call is 0, that means we have found 1 way to create the amount.
            - If the amount left is negative, that means this is an invalid way to create the amount, return 0.
            - If we finish using all our denominators, there are no more denominators to meet the amount, return 0.
    2) Top down approach, recursive method with memoization
        - If we are using the approach as described in 1). There will be overlapping recursion when calculating the number of ways.
        - In order to prevent doing redundant work, we will use memoization to cache previously calculated results
            - We will be using a hashtable to cache previous results
                - What should the key be?
                    - Can the key be just be the denominator that we are calculating?
                        - No, our overlapping recursions are concerned with the number of ways to make an amount with a certain denominator,
                          that means our keys need to know the current denominator and the amount left.
                    - key = amountLeft + ", " + currentIndex (our current index specifies which denominator we are currently using)
                    - value = the number of ways to create this amount with the specific denominator














