Question
    Given a sorted array of n integers that has been rotated an unknown
    number of times, write code to find an element in the array. You may assume that the array was
    originally sorted in increasing order.

Thoughts before Coding
    - This question is very similar to finding to the pivot point in a rotated array
        - In that example, we search through the array by comparing our middle element with our leftmost element
        - this will determine if our pivot point is on the left or the right
    - We can use a similar binary search strategy in this problem
        - In this question, one half of the array must be sorted in ascending order
        - For example
            - If our middle element is greater than our left element
                - that means our left side is in ascending order
            - If our middle element is less than our left element
                - that means our right side is in ascending order
        - Can we use this rule in our problem?

Answer
    - In this solution, we will perform a recursive binary search
    - In each of the iteration, we need values
        - leftmost index
        - rightmost index
        - middle index
    - If our middle element equals the value we are searching for, we will return the index
    - If our right index is less than our left index, we have failed to find a value, return -1 as index

    - We now have to consider the following cases
        - What if the value of our middle element is less than our left element?
            - This means the right side is sorted in ascending order
            - If our target 'x' is greater than our middle element and less than or equal to our right element
                - We will search to the right, (mid + 1) -> right
            - Else we will search to the left, left -> (mid - 1)
        - What if the value of our middle element is greater than our left element?
            - This means our left side is sorted
            - If our target 'x' is greater than or equal to our left element and less than our middle element
                - We will search to the left, left -> (mid - 1)
            - Else we will search to the right, (mid + 1) -> right
        - What happens if our middle element is equal to our left element?
            - If our middle element is not equal to our right element
                - We can search on the right, (mid + 1) -> right
            - Else, we will have to search on both sides
                - Search on the left, left -> (mid + 1)
                - If not found on the left
                    - return a search on the right, (mid + 1) -> right

    - What is the time/space complexity?
        - Time complexity
            - O(logn), average case -  if there are no duplicate elements
            - O(n), worst cast - if there are duplicate elements
        - Space complexity  - recursive stack memory
            - O(logn), average case -  if there are no duplicate elements
            - O(n), worst cast - if there are duplicate elements