Question
    Rank from Stream: Imagine you are reading in a stream of integers. Periodically, you wish
    to be able to look up the rank of a number x (the number of values less than or equal to x).
    Implement the data structures and algorithms to support these operations. That is, implement
    the method track(int x), which is called when each number is generated, and the method
    getRankOfNumber(int x), which returns the number of values less than or equal to x (not
    including x itself).

    EXAMPLE
        Stream(in order of appearance):5, 1, 4, 4, 5, 9, 7, 13, 3
        getRankOfNumber(l) 0
        getRankOfNumber(3) 1
        getRankOfNumber(4) 3

Thoughts before coding
    - We need to keep track of all of the elements that are smaller than our current element
    - One of the ways is to keep track of the elements in a sorted array
        - When inserting elements into our sorted array
            - it may take O(n) time to shift all of the elements over to create a space for the new element
        - When looking for the rank of the element
            - We can do a binary search on the element
            - then return the specific index of the element, which will be O(logn)
            - The time complexity of this operation is O(logn)
    - Since we are using so much time to insert an element, we should find a more efficient way.

Solution
    - We can use a binary search tree, where insertion of node can be O(logn) - balanced binary tree
    - Now how do we know the rank of the current node?
        - We will use a recursive approach to solve this problem
        - If our current node equals our target node, then we only need to find the size of its left subtree
            - We don't need include our current node in the count because it is zero based
            - We can do an in-order traversal to find the size of our left tree
        - What if our target node is less than our current node?
            - If our left child is null, we have to return -1, we have failed to find our target node
            - we will have to traverse to the left to find the node
            - Then return the left tree size of that node
        - What if our target node is greater than our current node?
            - If our right child is null, we have to return -1, we have failed to find our target node
                - If our right child is not null, we have to find the rank of our node in our right subtree
            - We will need to accumulate the sum of
                - The number of nodes in our left subtree
                - our current node
                - The rank of our node that we have found
    - It can be very inefficient to always do an in-order traversal when looking for size of our left subtree
        - We can keep an extra field inside our tree nodes that keeps track of our left subtree
        - We will update the counter, if any new nodes is inserted to the node's left subtree





