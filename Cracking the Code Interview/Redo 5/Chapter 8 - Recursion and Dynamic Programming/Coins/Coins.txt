Question
    Given an infinite number of quarters (25 cents), dimes (10 cents), nickels (5 cents), and
    pennies (1 cent), write code to calculate the number of ways of representing n cents.

Answer
    - There are three approaches to this problem, but we will only discuss the first 2 solutions
    1) The first solution is using recursion
        - Imagine the amount that we are trying to build is 100 and our denominators are {25, 10, 5, 1}
        - We will first start with our first denominator (quarter)
            - We will check how many ways to create 100 using quarters as long as it does not overshoot the amount
                - 0 quarters
                - 1 quarters - (75 cent left)
                - 2 quarters - (50 cent left)
                - 3 quarters - (25 cent left)
                - 4 quarters - (0 cent left) - 1 way
            - For each of the remaining amounts, we will use it for the other denominators
        - If we reach our last denominator (1 cent), we know that we have found 1 way to creating the amount, so we return 1.
          This is because any amount that is greater or equal to zero can be created with 1 cent.
            - if the remaining amount is 0, we can just use zero (1 cent)
        - Will we ever have a negative remaining amount before we reach our 1 cent denominator?
            - No, this is because our 'for' loop makes sure it does not overshoot the amount, before passing it to the next denominator
        - return the number of ways we have found in each recursive call
        - This first solution has a lot of overlapping recursive calls with the same amount and denominator index, we can fix this using memoization

    2) Our second solution will use recursion with memoization
        - In our previous problem, we have overlapping recursive calls regarding amount and denominator
        - We need to find a way to cache our results from previous recursive calls
        - What is the key and value pairs that we need to cache?
            - Since, we care about the numbers of ways regarding an amount and denominator
                - key -> amount and denominator index
                - value -> number of ways to represent the amount with the denominator index
        - What data structure are we using for this memo?
            - Since, we care about both amount and denominator index, we can use a 2D array
            - Hashtable also works
        - In each of the recursive call, we should check if our result is already cached in our memo before calculating for the number of ways
        - But, if our memo does not have the result, we will calculate the result and then store it inside our memo
        - return the number of ways

Gotcha
    - We have one cent as a denominator at the last index
        - Inside our 'for' loop, we make sure we don't overshoot the amount with the current denominator before going to the next denominator
        - As soon as we can reach our last denominator index, we are able to create one way
            - This is because for any amount greater than or equal to zero, we are able to create 1 way with 1 cent.
        - In the other problem inside interview cake, we may or may not have a coin that is worth (1).
            - so, our last denominator may or may not be able to create 1 way
            - we have to check if our amount remaining does not go below zero and only create 1 way if the remaining amount equals to 0.